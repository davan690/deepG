#' generate states list for tSNE from a fasta folder
#' it is expected that the length of each fasta file is equal
#'
#' @param fasta.folder path to fasta folder
#' @param model.path path to model file
#' @param maxlen length of semi-redundant chunks
#' @param batch.size how many chunks are predicted in parallel
#' @param save if TRUE, output will be written to file
#' @param save.path if save is TRUE, specifies output file path where states will be appended to
#' @param verbose write outut to screen
#' @export
generateStatesFromFolder <- function(fasta.folder = "example_files/fasta",
                                    model.path = "example_files/dummy_model_cpu.hdf5",
                                    maxlen = 80,
                                    batch.size = 500,
                                    save = F,
                                    save.path = "states.csv",
                                    verbose = T){
  files <- list.files(fasta.folder, full.names = T)
  states.list <- list()
  model <- keras::load_model_hdf5(model.path)
  # Remove the last 2 layers
  keras::pop_layer(model)
  keras::pop_layer(model)
  
  for (file in files) {
    message(paste("processing: ", file))
    states <- getStatesFromFasta(model = model,
                                 fasta.path = file, 
                              batch.size = batch.size,
                              maxlen = maxlen,
                              verbose = T)

    if (save) {
      write.table(states, file = save.path, append = T, quote = F, col.names = F)
      message(paste("saved states to", save.path))
    } else {
      # keep in memory
      states.list[[tools::file_path_sans_ext(basename(file))]] <- states
      return(states.list)
    }
  }
}

#' run the tSNE on a cell from the states.list, return list which contains the output of the Rtsne and the sample ids
#'
#' @param states.list list of states generated by generateStatesromFolder
#' @param cell.number number of cell/neuron that should go into tSNE
#' @param flatten if true, all cells will be used
#' @perplexity Perplexity parameter (should not be bigger than 3 * perplexity < nrow(X) - 1, see details for interpretation)
#' @pca Whether an initial PCA step should be performed (default: TRUE)
#' @max_iter Number of iterations (default: 1000)
#' @export
tsneFromStates <- function(states.list,
                           cell.number = 2,
                           flatten = FALSE,
                           perplexity = 1,
                           pca = TRUE,
                           max_iter = 1000) {
  dim <- c(dim(data.frame(states.list[[1]]))[1],
           dim(data.frame(states.list[[1]]))[2],
           length(states.list)) # should be 920 512 6 on example  
  states.array <- array(as.numeric(unlist(states.list)),
                        dim = dim)
  if (flatten) {
    states <- t(do.call('rbind',lapply(1:dim(states.array)[3],
                                       function(x) cbind(states.array[x,,], t = x)))) # bring 3dim array to 2D
  } else {
    states <- t(states.array[,cell.number,])
  }
  tsne <- Rtsne::Rtsne(states, dims = 2,
                       perplexity = perplexity,
                       check_duplicates = FALSE,
                       pca = pca,
                       max_iter = max_iter)
  return(list("ids" =  names(states.list), "tsne" = tsne))
}

#' plot tSNE
#' 
#' @param tsne deepTsne S4 from tsneFromStates
#' @param path.metadata file used for coloring
#' @param sample.name.column colun in metadata file that holds the sample name
#' @param label.name.column column that holds the label name in path.metadata
#' @param color.column column that holds the color information in path.metadata
#' @param 
#' @export
plotTsne <- function(tsne,
                     path.metadata = NULL,
                     sample.name.column = 1,
                     label.name.column = 2,
                     color.column = 3){
  if (!is.null(path.metadata)) {
    meta <- read.csv2(path.metadata, header = F, stringsAsFactors = F)
    colors <- meta[match(tsne$ids, meta[,sample.name.column]),][,color.column]
    labels <- meta[match(tsne$ids, meta[,sample.name.column]),][,label.name.column]
    tsne.df <- data.frame(x = tsne$tsne$Y[,1],
                          y = tsne$tsne$Y[,2],
                          labels = labels,
                          col = colors, stringsAsFactors = F)
    p <- ggplot2::ggplot(tsne.df, ggplot2::aes(x = x, y = y, color = labels))
  } else {
    tsne.df <- data.frame(x = tsne$tsne$Y[,1],
                          y = tsne$tsne$Y[,2],
                          stringsAsFactors = F)
    p <- ggplot2::ggplot(tsne.df, ggplot2::aes(x = x, y = y)) 
  }
  p <- p + ggplot2::geom_point()
  p <- p + ggplot2::theme_bw()
  return(p)
}
